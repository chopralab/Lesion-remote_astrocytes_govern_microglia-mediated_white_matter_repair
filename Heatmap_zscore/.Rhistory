mutate(across(all_of(intensity_columns), ~replace(., is.na(.), 0)))
# Remove rows where all values in intensity_columns are zeros
df <- df %>% filter(rowSums(.[intensity_columns]) > 0)
# Divide each value in intensity_columns by the sum of that column
df <- df %>%
mutate(across(all_of(intensity_columns),
~ . / sum(. , na.rm = TRUE)))
# Compute Z-scores
df <- df %>%
rowwise() %>%
mutate(across(all_of(intensity_columns),
~ ( . - mean(c_across(all_of(intensity_columns)), na.rm = TRUE)) /
sd(c_across(all_of(intensity_columns)), na.rm = TRUE))) %>%
ungroup()
labels_title_1 <- unique(df$Title_1)
labels_title_2 <- unique(df$Title_2)
labels_title_3 <- unique(df$Title_1_df2)
labels_title_4 <- unique(df$Title_2_df2)
annotation_labels <- c(rep(labels_title_1, each=df$Length1[1]),
rep(labels_title_2, each=df$Length2[1]),
rep(labels_title_3, each=df$Length1_df2[1]),
rep(labels_title_4, each=df$Length2_df2[1]))
# Function to save pheatmap as PDF
save_pheatmap_pdf <- function(x, filename, width=4, height=4) {
stopifnot(!missing(x))
stopifnot(!missing(filename))
pdf(filename, width=width, height=height)
grid::grid.newpage()
grid::grid.draw(x$gtable)
dev.off()
}
# df_filtered <- df %>% arrange(type.x) # Assuming type is consistent across both dataframes
df_filtered <- df %>% arrange(type.x, desc(LogFC.x))
View(df)
# df_filtered <- df %>% arrange(type.x) # Assuming type is consistent across both dataframes
df_filtered <- df %>% arrange(type.x, desc(logFC.x))
heatmap_breaks <- seq(-2, 2, length.out = 100)
annotation_data <- data.frame(type = df_filtered$type.x) # Assuming type is consistent across both dataframes
first_occurrence <- !duplicated(df_filtered$type.x)
df_filtered$Row_Label <- ifelse(first_occurrence, df_filtered$type.x, "")
annotation_col_df <- data.frame(Labels = annotation_labels)
rownames(annotation_col_df) <- colnames(df_filtered[intensity_columns])
heatmap_obj <- pheatmap::pheatmap(df_filtered[intensity_columns],
main = title,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_colnames = TRUE,
show_rownames = TRUE,
breaks = heatmap_breaks,
border_color = "black",
fontsize = 10,
fontsize_legend = 25,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "PRGn")))(100),
labels_row = df_filtered$Row_Label,
annotation_col = annotation_col_df)
# Save the heatmap
save_pheatmap_pdf(heatmap_obj, paste0("heatmaps_large/", title, "_Zscore_2_limit.pdf"), width = 11, height = 10)
names_to_include <- read.csv("filtered_df.csv")
function (x, df1, df2, ncp, log = FALSE)
names_to_include <- read.csv("filtered_df.csv")
#   # Read and preprocess the data
df2 <- read.csv("results/Genotype_ cKO__time point_ 28d ISCI vs Genotype_ cKO__time point_ healthynew_run_full.csv", stringsAsFactors = FALSE)
df1 <- read.csv("results/Genotype_ WT__time point_ 28d ISCI vs Genotype_ WT__time point_ healthynew_run_full.csv", stringsAsFactors = FALSE)
df1 <- df1 %>% filter(lipid %in% names_to_include$lipid)
df2 <- df2 %>% filter(lipid %in% names_to_include$lipid)
title <- "Heatmap_only_sig"
names_to_fix <- readxl::read_xlsx("Names_to_fix.xlsx")
names_to_fix <- names_to_fix[!is.na(names_to_fix$New_name) & names_to_fix$New_name != "",]
name_changes <- setNames(names_to_fix$New_name, names_to_fix$lipid)
# Replace lipid names in df using the named vector
df1$lipid <- ifelse(df1$lipid %in% names(name_changes), name_changes[df1$lipid], df1$lipid)
df2$lipid <- ifelse(df2$lipid %in% names(name_changes), name_changes[df2$lipid], df2$lipid)
# Rename columns in df2 to avoid conflicts when joining
names(df2)[names(df2) %in% c("Title_1", "Title_2", "Length1", "Length2")] <- paste0(names(df2)[names(df2) %in% c("Title_1", "Title_2", "Length1", "Length2")], "_df2")
# Merge dataframes on 'lipid'
df <- merge(df1, df2, by = "lipid", all = TRUE)
# Arrange dataframe
df <- df %>%
arrange(lipid)
# Identify intensity columns
intensity_columns <- setdiff(names(df), c("lipid","Blank.1x.x", "logFC.x", "logCPM.x", "LR.x", "PValue.x", "FDR.x", "Length1", "Length2", "Title_1", "Title_2", "type.x", "logFC.y", "logCPM.y", "LR.y", "PValue.y", "FDR.y", "Length1_df2", "Length2_df2", "Title_1_df2", "Title_2_df2", "type.y", tail(names(df), 1)))
# Get the blank column (assuming it's the last column in the dataframe)
blank_col <- tail(names(df), 1)
# Subtract the blank column from the intensity columns and set negative values to 0
df[intensity_columns] <- pmax(df[intensity_columns] - df[[blank_col]], 0)
df <- df %>%
mutate(across(all_of(intensity_columns), ~replace(., is.infinite(.), NA))) %>%
mutate(across(all_of(intensity_columns), ~replace(., is.na(.), 0)))
# Remove rows where all values in intensity_columns are zeros
df <- df %>% filter(rowSums(.[intensity_columns]) > 0)
# Divide each value in intensity_columns by the sum of that column
df <- df %>%
mutate(across(all_of(intensity_columns),
~ . / sum(. , na.rm = TRUE)))
# Compute Z-scores
df <- df %>%
rowwise() %>%
mutate(across(all_of(intensity_columns),
~ ( . - mean(c_across(all_of(intensity_columns)), na.rm = TRUE)) /
sd(c_across(all_of(intensity_columns)), na.rm = TRUE))) %>%
ungroup()
labels_title_1 <- unique(df$Title_1)
labels_title_2 <- unique(df$Title_2)
labels_title_3 <- unique(df$Title_1_df2)
labels_title_4 <- unique(df$Title_2_df2)
annotation_labels <- c(rep(labels_title_1, each=df$Length1[1]),
rep(labels_title_2, each=df$Length2[1]),
rep(labels_title_3, each=df$Length1_df2[1]),
rep(labels_title_4, each=df$Length2_df2[1]))
# Function to save pheatmap as PDF
save_pheatmap_pdf <- function(x, filename, width=4, height=4) {
stopifnot(!missing(x))
stopifnot(!missing(filename))
pdf(filename, width=width, height=height)
grid::grid.newpage()
grid::grid.draw(x$gtable)
dev.off()
}
conditions <- list(
list(filter = TRUE, suffix = "_by_class2"),
list(filter = FALSE, suffix = "_by_class")
)
for (lipid_type in unique(df$type)) {
df_filtered_by_type <- df %>% filter(type == lipid_type)
for (condition in conditions) {
if (condition$filter) {
df_filtered <- df_filtered_by_type
} else {
df_filtered <- df_filtered_by_type
}
if(nrow(df_filtered) < 1) {
next
}
# df_filtered <- df %>% arrange(type.x) # Assuming type is consistent across both dataframes
df_filtered <- df %>% arrange(type.x, desc(logFC.x))
title_suffix <- condition$suffix
heatmap_breaks <- seq(-2, 2, length.out = 100)
annotation_data <- data.frame(type = df_filtered$type)
# Adjust the row annotations to use lipid:
annotation_col_df <- data.frame(Labels = annotation_labels)
rownames(annotation_col_df) <- colnames(df_filtered[intensity_columns])
heatmap_obj <- pheatmap::pheatmap(df_filtered[intensity_columns],
main = paste0(title, "_", lipid_type, title_suffix),
cluster_rows = FALSE,
cluster_cols = FALSE,
show_colnames = TRUE,
show_rownames = TRUE,
breaks = heatmap_breaks,
border_color = "black",
fontsize = 10,
fontsize_legend = 25,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
labels_row = df_filtered$lipid, # Use lipid for row labels
annotation_col = annotation_col_df)  # Column annotations
save_pheatmap_pdf(heatmap_obj, paste0("heatmaps_large_by_class/", title, "_", lipid_type, title_suffix, ".pdf"), width = 11, height = 10)
}
}
for (lipid_type in unique(df$type.x)) {
df_filtered_by_type <- df %>% filter(type.x == lipid_type)
for (condition in conditions) {
if (condition$filter) {
df_filtered <- df_filtered_by_type
} else {
df_filtered <- df_filtered_by_type
}
if(nrow(df_filtered) < 1) {
next
}
# df_filtered <- df %>% arrange(type.x) # Assuming type is consistent across both dataframes
df_filtered <- df %>% arrange(type.x, desc(logFC.x))
title_suffix <- condition$suffix
heatmap_breaks <- seq(-2, 2, length.out = 100)
annotation_data <- data.frame(type = df_filtered$type)
# Adjust the row annotations to use lipid:
annotation_col_df <- data.frame(Labels = annotation_labels)
rownames(annotation_col_df) <- colnames(df_filtered[intensity_columns])
heatmap_obj <- pheatmap::pheatmap(df_filtered[intensity_columns],
main = paste0(title, "_", lipid_type, title_suffix),
cluster_rows = FALSE,
cluster_cols = FALSE,
show_colnames = TRUE,
show_rownames = TRUE,
breaks = heatmap_breaks,
border_color = "black",
fontsize = 10,
fontsize_legend = 25,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
labels_row = df_filtered$lipid, # Use lipid for row labels
annotation_col = annotation_col_df)  # Column annotations
save_pheatmap_pdf(heatmap_obj, paste0("heatmaps_large_by_class/", title, "_", lipid_type, title_suffix, ".pdf"), width = 11, height = 10)
}
}
View(df)
lipid_type <- "CAR"
df_filtered_by_type <- df %>% filter(type.x == lipid_type)
View(df_filtered_by_type)
df_filtered <- df_filtered_by_type
# df_filtered <- df %>% arrange(type.x) # Assuming type is consistent across both dataframes
df_filtered <- df_filtered %>% arrange(type.x, desc(logFC.x))
title_suffix <- condition$suffix
heatmap_breaks <- seq(-2, 2, length.out = 100)
annotation_data <- data.frame(type = df_filtered$type)
# Adjust the row annotations to use lipid:
annotation_col_df <- data.frame(Labels = annotation_labels)
for (lipid_type in unique(df$type.x)) {
df_filtered_by_type <- df %>% filter(type.x == lipid_type)
for (condition in conditions) {
if (condition$filter) {
df_filtered <- df_filtered_by_type
} else {
df_filtered <- df_filtered_by_type
}
if(nrow(df_filtered) < 1) {
next
}
# df_filtered <- df %>% arrange(type.x) # Assuming type is consistent across both dataframes
df_filtered <- df_filtered %>% arrange(type.x, desc(logFC.x))
title_suffix <- condition$suffix
heatmap_breaks <- seq(-2, 2, length.out = 100)
annotation_data <- data.frame(type = df_filtered$type.x)
# Adjust the row annotations to use lipid:
annotation_col_df <- data.frame(Labels = annotation_labels)
rownames(annotation_col_df) <- colnames(df_filtered[intensity_columns])
heatmap_obj <- pheatmap::pheatmap(df_filtered[intensity_columns],
main = paste0(title, "_", lipid_type, title_suffix),
cluster_rows = FALSE,
cluster_cols = FALSE,
show_colnames = TRUE,
show_rownames = TRUE,
breaks = heatmap_breaks,
border_color = "black",
fontsize = 10,
fontsize_legend = 25,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
labels_row = df_filtered$lipid, # Use lipid for row labels
annotation_col = annotation_col_df)  # Column annotations
save_pheatmap_pdf(heatmap_obj, paste0("heatmaps_large_by_class/", title, "_", lipid_type, title_suffix, ".pdf"), width = 11, height = 10)
}
}
conditions <- list(
list(filter = TRUE, suffix = "_by_class2_1_limit"),
list(filter = FALSE, suffix = "_by_class_1_limit")
)
for (lipid_type in unique(df$type.x)) {
df_filtered_by_type <- df %>% filter(type.x == lipid_type)
for (condition in conditions) {
if (condition$filter) {
df_filtered <- df_filtered_by_type
} else {
df_filtered <- df_filtered_by_type
}
if(nrow(df_filtered) < 1) {
next
}
# df_filtered <- df %>% arrange(type.x) # Assuming type is consistent across both dataframes
df_filtered <- df_filtered %>% arrange(type.x, desc(logFC.x))
title_suffix <- condition$suffix
heatmap_breaks <- seq(-1, 1, length.out = 100)
annotation_data <- data.frame(type = df_filtered$type.x)
# Adjust the row annotations to use lipid:
annotation_col_df <- data.frame(Labels = annotation_labels)
rownames(annotation_col_df) <- colnames(df_filtered[intensity_columns])
heatmap_obj <- pheatmap::pheatmap(df_filtered[intensity_columns],
main = paste0(title, "_", lipid_type, title_suffix),
cluster_rows = FALSE,
cluster_cols = FALSE,
show_colnames = TRUE,
show_rownames = TRUE,
breaks = heatmap_breaks,
border_color = "black",
fontsize = 10,
fontsize_legend = 25,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
labels_row = df_filtered$lipid, # Use lipid for row labels
annotation_col = annotation_col_df)  # Column annotations
save_pheatmap_pdf(heatmap_obj, paste0("heatmaps_large_by_class/", title, "_", lipid_type, title_suffix, ".pdf"), width = 11, height = 10)
}
}
conditions <- list(
list(filter = TRUE, suffix = "_by_class2"),
list(filter = FALSE, suffix = "_by_class")
)
lipid_type <- "CAR"
for (lipid_type in unique(df$type.x)) {
df_filtered_by_type <- df %>% filter(type.x == lipid_type)
for (condition in conditions) {
if (condition$filter) {
df_filtered <- df_filtered_by_type
} else {
df_filtered <- df_filtered_by_type
}
if(nrow(df_filtered) < 1) {
next
}
# df_filtered <- df %>% arrange(type.x) # Assuming type is consistent across both dataframes
df_filtered <- df_filtered %>% arrange(type.x, desc(logFC.x))
title_suffix <- condition$suffix
heatmap_breaks <- seq(-2, 2, length.out = 100)
annotation_data <- data.frame(type = df_filtered$type.x)
# Adjust the row annotations to use lipid:
annotation_col_df <- data.frame(Labels = annotation_labels)
rownames(annotation_col_df) <- colnames(df_filtered[intensity_columns])
heatmap_obj <- pheatmap::pheatmap(df_filtered[intensity_columns],
main = paste0(title, "_", lipid_type, title_suffix),
cluster_rows = FALSE,
cluster_cols = FALSE,
show_colnames = TRUE,
show_rownames = TRUE,
breaks = heatmap_breaks,
border_color = "black",
fontsize = 10,
fontsize_legend = 25,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "PRGn")))(100),
labels_row = df_filtered$lipid, # Use lipid for row labels
annotation_col = annotation_col_df)  # Column annotations
save_pheatmap_pdf(heatmap_obj, paste0("heatmaps_large_by_class/", title, "_", lipid_type, title_suffix, ".pdf"), width = 11, height = 10)
}
}
library(tidyverse)
library(pheatmap)
library(RColorBrewer)
library(dplyr)
library(RColorBrewer)
# File path
library(readxl)
create_heatmap_Z_score <- function(df1, df2, title,names_to_include) {
# Rename columns in df2 to avoid conflicts when joining
names(df2)[names(df2) %in% c("Title_1", "Title_2", "Length1", "Length2")] <- paste0(names(df2)[names(df2) %in% c("Title_1", "Title_2", "Length1", "Length2")], "_df2")
# Merge dataframes on 'lipid'
df <- merge(df1, df2, by = "lipid", all = TRUE)
# Arrange dataframe
df <- df %>%
arrange(lipid)
# Identify intensity columns
intensity_columns <- setdiff(names(df), c("lipid","Blank.1x.x", "logFC.x", "logCPM.x", "LR.x", "PValue.x", "FDR.x", "Length1", "Length2", "Title_1", "Title_2", "type.x", "logFC.y", "logCPM.y", "LR.y", "PValue.y", "FDR.y", "Length1_df2", "Length2_df2", "Title_1_df2", "Title_2_df2", "type.y", tail(names(df), 1)))
# Get the blank column (assuming it's the last column in the dataframe)
blank_col <- tail(names(df), 1)
# Subtract the blank column from the intensity columns and set negative values to 0
df[intensity_columns] <- pmax(df[intensity_columns] - df[[blank_col]], 0)
df <- df %>%
mutate(across(all_of(intensity_columns), ~replace(., is.infinite(.), NA))) %>%
mutate(across(all_of(intensity_columns), ~replace(., is.na(.), 0)))
# Remove rows where all values in intensity_columns are zeros
df <- df %>% filter(rowSums(.[intensity_columns]) > 0)
write.csv(df[intensity_columns], "Blank_subtracted.csv", row.names = FALSE)
# Divide each value in intensity_columns by the sum of that column
df <- df %>%
mutate(across(all_of(intensity_columns),
~ . / sum(. , na.rm = TRUE)))
df <- df %>% filter(lipid %in% names_to_include$lipid)
write.csv(df[intensity_columns], "Blank_subtracted_and_column_normalized.csv", row.names = FALSE)
# Compute Z-scores
df <- df %>%
rowwise() %>%
mutate(across(all_of(intensity_columns),
~ ( . - mean(c_across(all_of(intensity_columns)), na.rm = TRUE)) /
sd(c_across(all_of(intensity_columns)), na.rm = TRUE))) %>%
ungroup()
write.csv(df[intensity_columns], "Blank_subtracted_and_column_normalized_and_Zscore.csv", row.names = FALSE)
labels_title_1 <- unique(df$Title_1)
labels_title_2 <- unique(df$Title_2)
labels_title_3 <- unique(df$Title_1_df2)
labels_title_4 <- unique(df$Title_2_df2)
annotation_labels <- c(rep(labels_title_1, each=df$Length1[1]),
rep(labels_title_2, each=df$Length2[1]),
rep(labels_title_3, each=df$Length1_df2[1]),
rep(labels_title_4, each=df$Length2_df2[1]))
# Function to save pheatmap as PDF
save_pheatmap_pdf <- function(x, filename, width=4, height=4) {
stopifnot(!missing(x))
stopifnot(!missing(filename))
pdf(filename, width=width, height=height)
grid::grid.newpage()
grid::grid.draw(x$gtable)
dev.off()
}
# df_filtered <- df %>% arrange(type.x) # Assuming type is consistent across both dataframes
df_filtered <- df %>% arrange(type.x, desc(logFC.x))
heatmap_breaks <- seq(-2, 2, length.out = 100)
annotation_data <- data.frame(type = df_filtered$type.x) # Assuming type is consistent across both dataframes
first_occurrence <- !duplicated(df_filtered$type.x)
df_filtered$Row_Label <- ifelse(first_occurrence, df_filtered$type.x, "")
annotation_col_df <- data.frame(Labels = annotation_labels)
rownames(annotation_col_df) <- colnames(df_filtered[intensity_columns])
heatmap_obj <- pheatmap::pheatmap(df_filtered[intensity_columns],
main = title,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_colnames = TRUE,
show_rownames = TRUE,
breaks = heatmap_breaks,
border_color = "black",
fontsize = 10,
fontsize_legend = 25,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "PRGn")))(100),
labels_row = df_filtered$Row_Label,
annotation_col = annotation_col_df)
# Save the heatmap
save_pheatmap_pdf(heatmap_obj, paste0("heatmaps_large/", title, "_Zscore_2_limit.pdf"), width = 11, height = 10)
}
create_heatmap_Z_score_per_class <- function(df1, df2, title,names_to_include) {
# Rename columns in df2 to avoid conflicts when joining
names(df2)[names(df2) %in% c("Title_1", "Title_2", "Length1", "Length2")] <- paste0(names(df2)[names(df2) %in% c("Title_1", "Title_2", "Length1", "Length2")], "_df2")
# Merge dataframes on 'lipid'
df <- merge(df1, df2, by = "lipid", all = TRUE)
# Arrange dataframe
df <- df %>%
arrange(lipid)
# Identify intensity columns
intensity_columns <- setdiff(names(df), c("lipid","Blank.1x.x", "logFC.x", "logCPM.x", "LR.x", "PValue.x", "FDR.x", "Length1", "Length2", "Title_1", "Title_2", "type.x", "logFC.y", "logCPM.y", "LR.y", "PValue.y", "FDR.y", "Length1_df2", "Length2_df2", "Title_1_df2", "Title_2_df2", "type.y", tail(names(df), 1)))
# Get the blank column (assuming it's the last column in the dataframe)
blank_col <- tail(names(df), 1)
# Subtract the blank column from the intensity columns and set negative values to 0
df[intensity_columns] <- pmax(df[intensity_columns] - df[[blank_col]], 0)
df <- df %>%
mutate(across(all_of(intensity_columns), ~replace(., is.infinite(.), NA))) %>%
mutate(across(all_of(intensity_columns), ~replace(., is.na(.), 0)))
# Remove rows where all values in intensity_columns are zeros
df <- df %>% filter(rowSums(.[intensity_columns]) > 0)
# Divide each value in intensity_columns by the sum of that column
df <- df %>%
mutate(across(all_of(intensity_columns),
~ . / sum(. , na.rm = TRUE)))
df <- df %>% filter(lipid %in% names_to_include$lipid)
# Compute Z-scores
df <- df %>%
rowwise() %>%
mutate(across(all_of(intensity_columns),
~ ( . - mean(c_across(all_of(intensity_columns)), na.rm = TRUE)) /
sd(c_across(all_of(intensity_columns)), na.rm = TRUE))) %>%
ungroup()
labels_title_1 <- unique(df$Title_1)
labels_title_2 <- unique(df$Title_2)
labels_title_3 <- unique(df$Title_1_df2)
labels_title_4 <- unique(df$Title_2_df2)
annotation_labels <- c(rep(labels_title_1, each=df$Length1[1]),
rep(labels_title_2, each=df$Length2[1]),
rep(labels_title_3, each=df$Length1_df2[1]),
rep(labels_title_4, each=df$Length2_df2[1]))
# Function to save pheatmap as PDF
save_pheatmap_pdf <- function(x, filename, width=4, height=4) {
stopifnot(!missing(x))
stopifnot(!missing(filename))
pdf(filename, width=width, height=height)
grid::grid.newpage()
grid::grid.draw(x$gtable)
dev.off()
}
conditions <- list(
list(filter = TRUE, suffix = "_by_class2"),
list(filter = FALSE, suffix = "_by_class")
)
lipid_type <- "CAR"
for (lipid_type in unique(df$type.x)) {
df_filtered_by_type <- df %>% filter(type.x == lipid_type)
for (condition in conditions) {
if (condition$filter) {
df_filtered <- df_filtered_by_type
} else {
df_filtered <- df_filtered_by_type
}
if(nrow(df_filtered) < 1) {
next
}
# df_filtered <- df %>% arrange(type.x) # Assuming type is consistent across both dataframes
df_filtered <- df_filtered %>% arrange(type.x, desc(logFC.x))
title_suffix <- condition$suffix
heatmap_breaks <- seq(-2, 2, length.out = 100)
annotation_data <- data.frame(type = df_filtered$type.x)
# Adjust the row annotations to use lipid:
annotation_col_df <- data.frame(Labels = annotation_labels)
rownames(annotation_col_df) <- colnames(df_filtered[intensity_columns])
heatmap_obj <- pheatmap::pheatmap(df_filtered[intensity_columns],
main = paste0(title, "_", lipid_type, title_suffix),
cluster_rows = FALSE,
cluster_cols = FALSE,
show_colnames = TRUE,
show_rownames = TRUE,
breaks = heatmap_breaks,
border_color = "black",
fontsize = 10,
fontsize_legend = 25,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "PRGn")))(100),
labels_row = df_filtered$lipid, # Use lipid for row labels
annotation_col = annotation_col_df)  # Column annotations
save_pheatmap_pdf(heatmap_obj, paste0("heatmaps_large_by_class/", title, "_", lipid_type, title_suffix, ".pdf"), width = 11, height = 10)
}
}
}
library(tidyverse)
library(pheatmap)
library(RColorBrewer)
library(dplyr)
library(RColorBrewer)
# File path
library(readxl)
names_to_include <- read.csv("filtered_df.csv")
#   # Read and preprocess the data
df2 <- read.csv("Genotype_ cKO__reordered.csv", stringsAsFactors = FALSE)
df1 <- read.csv("Genotype_ WT___reordered.csv", stringsAsFactors = FALSE)
title <- "Heatmap_only_sig"
names_to_fix <- readxl::read_xlsx("Names_to_fix.xlsx")
names_to_fix <- names_to_fix[!is.na(names_to_fix$New_name) & names_to_fix$New_name != "",]
name_changes <- setNames(names_to_fix$New_name, names_to_fix$lipid)
# Replace lipid names in df using the named vector
df1$lipid <- ifelse(df1$lipid %in% names(name_changes), name_changes[df1$lipid], df1$lipid)
df2$lipid <- ifelse(df2$lipid %in% names(name_changes), name_changes[df2$lipid], df2$lipid)
create_heatmap_Z_score(df1, df2, title,names_to_include)
create_heatmap_Z_score_per_class(df1, df2, title,names_to_include)
names_to_include$lipid <- ifelse(names_to_include$lipid %in% names(name_changes), name_changes[names_to_include$lipid], names_to_include$lipid)
create_heatmap_Z_score_per_class(df1, df2, title,names_to_include)
create_heatmap_Z_score(df1, df2, title,names_to_include)
