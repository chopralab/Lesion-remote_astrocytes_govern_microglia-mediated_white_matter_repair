write.csv(df, "Blank_subtracted_and_column_normalized_and_Zscore.csv", row.names = FALSE)
labels_title_1 <- unique(df$Title_1)
labels_title_2 <- unique(df$Title_2)
labels_title_3 <- unique(df$Title_1_df2)
labels_title_4 <- unique(df$Title_2_df2)
annotation_labels <- c(rep(labels_title_1, each=df$Length1[1]),
rep(labels_title_2, each=df$Length2[1]),
rep(labels_title_3, each=df$Length1_df2[1]),
rep(labels_title_4, each=df$Length2_df2[1]))
# Function to save pheatmap as PDF
save_pheatmap_pdf <- function(x, filename, width=4, height=4) {
stopifnot(!missing(x))
stopifnot(!missing(filename))
pdf(filename, width=width, height=height)
grid::grid.newpage()
grid::grid.draw(x$gtable)
dev.off()
}
# df_filtered <- df %>% arrange(type.x) # Assuming type is consistent across both dataframes
df_filtered <- df %>% arrange(type.x, desc(logFC.x))
heatmap_breaks <- seq(-2, 2, length.out = 100)
annotation_data <- data.frame(type = df_filtered$type.x) # Assuming type is consistent across both dataframes
first_occurrence <- !duplicated(df_filtered$type.x)
df_filtered$Row_Label <- ifelse(first_occurrence, df_filtered$type.x, "")
annotation_col_df <- data.frame(Labels = annotation_labels)
rownames(annotation_col_df) <- colnames(df_filtered[intensity_columns])
heatmap_obj <- pheatmap::pheatmap(df_filtered[intensity_columns],
main = title,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_colnames = TRUE,
show_rownames = TRUE,
breaks = heatmap_breaks,
border_color = "black",
fontsize = 10,
fontsize_legend = 25,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "PRGn")))(100),
labels_row = df_filtered$Row_Label,
annotation_col = annotation_col_df)
# Save the heatmap
save_pheatmap_pdf(heatmap_obj, paste0("heatmaps_large/", title, "_Zscore_2_limit.pdf"), width = 11, height = 10)
}
create_heatmap_Z_score(df1, df2, title)
create_heatmap_Z_score <- function(df1, df2, title) {
# Rename columns in df2 to avoid conflicts when joining
names(df2)[names(df2) %in% c("Title_1", "Title_2", "Length1", "Length2")] <- paste0(names(df2)[names(df2) %in% c("Title_1", "Title_2", "Length1", "Length2")], "_df2")
# Merge dataframes on 'lipid'
df <- merge(df1, df2, by = "lipid", all = TRUE)
# Arrange dataframe
df <- df %>%
arrange(lipid)
# Identify intensity columns
intensity_columns <- setdiff(names(df), c("lipid","Blank.1x.x", "logFC.x", "logCPM.x", "LR.x", "PValue.x", "FDR.x", "Length1", "Length2", "Title_1", "Title_2", "type.x", "logFC.y", "logCPM.y", "LR.y", "PValue.y", "FDR.y", "Length1_df2", "Length2_df2", "Title_1_df2", "Title_2_df2", "type.y", tail(names(df), 1)))
# Get the blank column (assuming it's the last column in the dataframe)
blank_col <- tail(names(df), 1)
# Subtract the blank column from the intensity columns and set negative values to 0
df[intensity_columns] <- pmax(df[intensity_columns] - df[[blank_col]], 0)
df <- df %>%
mutate(across(all_of(intensity_columns), ~replace(., is.infinite(.), NA))) %>%
mutate(across(all_of(intensity_columns), ~replace(., is.na(.), 0)))
# Remove rows where all values in intensity_columns are zeros
df <- df %>% filter(rowSums(.[intensity_columns]) > 0)
write.csv(df, "Blank_subtracted.csv", row.names = FALSE)
# Divide each value in intensity_columns by the sum of that column
df <- df %>%
mutate(across(all_of(intensity_columns),
~ . / sum(. , na.rm = TRUE)))
write.csv(df, "Blank_subtracted_and_column_normalized.csv", row.names = FALSE)
# Compute Z-scores
df <- df %>%
rowwise() %>%
mutate(across(all_of(intensity_columns),
~ ( . - mean(c_across(all_of(intensity_columns)), na.rm = TRUE)) /
sd(c_across(all_of(intensity_columns)), na.rm = TRUE))) %>%
ungroup()
write.csv(df, "Blank_subtracted_and_column_normalized_and_Zscore.csv", row.names = FALSE)
labels_title_1 <- unique(df$Title_1)
labels_title_2 <- unique(df$Title_2)
labels_title_3 <- unique(df$Title_1_df2)
labels_title_4 <- unique(df$Title_2_df2)
annotation_labels <- c(rep(labels_title_1, each=df$Length1[1]),
rep(labels_title_2, each=df$Length2[1]),
rep(labels_title_3, each=df$Length1_df2[1]),
rep(labels_title_4, each=df$Length2_df2[1]))
# Function to save pheatmap as PDF
save_pheatmap_pdf <- function(x, filename, width=4, height=4) {
stopifnot(!missing(x))
stopifnot(!missing(filename))
pdf(filename, width=width, height=height)
grid::grid.newpage()
grid::grid.draw(x$gtable)
dev.off()
}
# df_filtered <- df %>% arrange(type.x) # Assuming type is consistent across both dataframes
df_filtered <- df %>% arrange(type.x, desc(logFC.x))
heatmap_breaks <- seq(-2, 2, length.out = 100)
annotation_data <- data.frame(type = df_filtered$type.x) # Assuming type is consistent across both dataframes
first_occurrence <- !duplicated(df_filtered$type.x)
df_filtered$Row_Label <- ifelse(first_occurrence, df_filtered$type.x, "")
annotation_col_df <- data.frame(Labels = annotation_labels)
rownames(annotation_col_df) <- colnames(df_filtered[intensity_columns])
heatmap_obj <- pheatmap::pheatmap(df_filtered[intensity_columns],
main = title,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_colnames = TRUE,
show_rownames = TRUE,
breaks = heatmap_breaks,
border_color = "black",
fontsize = 10,
fontsize_legend = 25,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "PRGn")))(100),
labels_row = df_filtered$Row_Label,
annotation_col = annotation_col_df)
# Save the heatmap
save_pheatmap_pdf(heatmap_obj, paste0("heatmaps_large/", title, "_Zscore_2_limit.pdf"), width = 11, height = 10)
}
create_heatmap_Z_score_per_class <- function(df1, df2, title) {
# Rename columns in df2 to avoid conflicts when joining
names(df2)[names(df2) %in% c("Title_1", "Title_2", "Length1", "Length2")] <- paste0(names(df2)[names(df2) %in% c("Title_1", "Title_2", "Length1", "Length2")], "_df2")
# Merge dataframes on 'lipid'
df <- merge(df1, df2, by = "lipid", all = TRUE)
# Arrange dataframe
df <- df %>%
arrange(lipid)
# Identify intensity columns
intensity_columns <- setdiff(names(df), c("lipid","Blank.1x.x", "logFC.x", "logCPM.x", "LR.x", "PValue.x", "FDR.x", "Length1", "Length2", "Title_1", "Title_2", "type.x", "logFC.y", "logCPM.y", "LR.y", "PValue.y", "FDR.y", "Length1_df2", "Length2_df2", "Title_1_df2", "Title_2_df2", "type.y", tail(names(df), 1)))
# Get the blank column (assuming it's the last column in the dataframe)
blank_col <- tail(names(df), 1)
# Subtract the blank column from the intensity columns and set negative values to 0
df[intensity_columns] <- pmax(df[intensity_columns] - df[[blank_col]], 0)
df <- df %>%
mutate(across(all_of(intensity_columns), ~replace(., is.infinite(.), NA))) %>%
mutate(across(all_of(intensity_columns), ~replace(., is.na(.), 0)))
# Remove rows where all values in intensity_columns are zeros
df <- df %>% filter(rowSums(.[intensity_columns]) > 0)
# Divide each value in intensity_columns by the sum of that column
df <- df %>%
mutate(across(all_of(intensity_columns),
~ . / sum(. , na.rm = TRUE)))
# Compute Z-scores
df <- df %>%
rowwise() %>%
mutate(across(all_of(intensity_columns),
~ ( . - mean(c_across(all_of(intensity_columns)), na.rm = TRUE)) /
sd(c_across(all_of(intensity_columns)), na.rm = TRUE))) %>%
ungroup()
labels_title_1 <- unique(df$Title_1)
labels_title_2 <- unique(df$Title_2)
labels_title_3 <- unique(df$Title_1_df2)
labels_title_4 <- unique(df$Title_2_df2)
annotation_labels <- c(rep(labels_title_1, each=df$Length1[1]),
rep(labels_title_2, each=df$Length2[1]),
rep(labels_title_3, each=df$Length1_df2[1]),
rep(labels_title_4, each=df$Length2_df2[1]))
# Function to save pheatmap as PDF
save_pheatmap_pdf <- function(x, filename, width=4, height=4) {
stopifnot(!missing(x))
stopifnot(!missing(filename))
pdf(filename, width=width, height=height)
grid::grid.newpage()
grid::grid.draw(x$gtable)
dev.off()
}
conditions <- list(
list(filter = TRUE, suffix = "_by_class2"),
list(filter = FALSE, suffix = "_by_class")
)
lipid_type <- "CAR"
for (lipid_type in unique(df$type.x)) {
df_filtered_by_type <- df %>% filter(type.x == lipid_type)
for (condition in conditions) {
if (condition$filter) {
df_filtered <- df_filtered_by_type
} else {
df_filtered <- df_filtered_by_type
}
if(nrow(df_filtered) < 1) {
next
}
# df_filtered <- df %>% arrange(type.x) # Assuming type is consistent across both dataframes
df_filtered <- df_filtered %>% arrange(type.x, desc(logFC.x))
title_suffix <- condition$suffix
heatmap_breaks <- seq(-2, 2, length.out = 100)
annotation_data <- data.frame(type = df_filtered$type.x)
# Adjust the row annotations to use lipid:
annotation_col_df <- data.frame(Labels = annotation_labels)
rownames(annotation_col_df) <- colnames(df_filtered[intensity_columns])
heatmap_obj <- pheatmap::pheatmap(df_filtered[intensity_columns],
main = paste0(title, "_", lipid_type, title_suffix),
cluster_rows = FALSE,
cluster_cols = FALSE,
show_colnames = TRUE,
show_rownames = TRUE,
breaks = heatmap_breaks,
border_color = "black",
fontsize = 10,
fontsize_legend = 25,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "PRGn")))(100),
labels_row = df_filtered$lipid, # Use lipid for row labels
annotation_col = annotation_col_df)  # Column annotations
save_pheatmap_pdf(heatmap_obj, paste0("heatmaps_large_by_class/", title, "_", lipid_type, title_suffix, ".pdf"), width = 11, height = 10)
}
}
}
create_heatmap_Z_score_per_class(df1, df2, title)
create_heatmap_Z_score <- function(df1, df2, title) {
# Rename columns in df2 to avoid conflicts when joining
names(df2)[names(df2) %in% c("Title_1", "Title_2", "Length1", "Length2")] <- paste0(names(df2)[names(df2) %in% c("Title_1", "Title_2", "Length1", "Length2")], "_df2")
# Merge dataframes on 'lipid'
df <- merge(df1, df2, by = "lipid", all = TRUE)
# Arrange dataframe
df <- df %>%
arrange(lipid)
# Identify intensity columns
intensity_columns <- setdiff(names(df), c("lipid","Blank.1x.x", "logFC.x", "logCPM.x", "LR.x", "PValue.x", "FDR.x", "Length1", "Length2", "Title_1", "Title_2", "type.x", "logFC.y", "logCPM.y", "LR.y", "PValue.y", "FDR.y", "Length1_df2", "Length2_df2", "Title_1_df2", "Title_2_df2", "type.y", tail(names(df), 1)))
# Get the blank column (assuming it's the last column in the dataframe)
blank_col <- tail(names(df), 1)
# Subtract the blank column from the intensity columns and set negative values to 0
df[intensity_columns] <- pmax(df[intensity_columns] - df[[blank_col]], 0)
df <- df %>%
mutate(across(all_of(intensity_columns), ~replace(., is.infinite(.), NA))) %>%
mutate(across(all_of(intensity_columns), ~replace(., is.na(.), 0)))
# Remove rows where all values in intensity_columns are zeros
df <- df %>% filter(rowSums(.[intensity_columns]) > 0)
write.csv(df[intensity_columns], "Blank_subtracted.csv", row.names = FALSE)
# Divide each value in intensity_columns by the sum of that column
df <- df %>%
mutate(across(all_of(intensity_columns),
~ . / sum(. , na.rm = TRUE)))
write.csv(df[intensity_columns], "Blank_subtracted_and_column_normalized.csv", row.names = FALSE)
# Compute Z-scores
df <- df %>%
rowwise() %>%
mutate(across(all_of(intensity_columns),
~ ( . - mean(c_across(all_of(intensity_columns)), na.rm = TRUE)) /
sd(c_across(all_of(intensity_columns)), na.rm = TRUE))) %>%
ungroup()
write.csv(df[intensity_columns], "Blank_subtracted_and_column_normalized_and_Zscore.csv", row.names = FALSE)
labels_title_1 <- unique(df$Title_1)
labels_title_2 <- unique(df$Title_2)
labels_title_3 <- unique(df$Title_1_df2)
labels_title_4 <- unique(df$Title_2_df2)
annotation_labels <- c(rep(labels_title_1, each=df$Length1[1]),
rep(labels_title_2, each=df$Length2[1]),
rep(labels_title_3, each=df$Length1_df2[1]),
rep(labels_title_4, each=df$Length2_df2[1]))
# Function to save pheatmap as PDF
save_pheatmap_pdf <- function(x, filename, width=4, height=4) {
stopifnot(!missing(x))
stopifnot(!missing(filename))
pdf(filename, width=width, height=height)
grid::grid.newpage()
grid::grid.draw(x$gtable)
dev.off()
}
# df_filtered <- df %>% arrange(type.x) # Assuming type is consistent across both dataframes
df_filtered <- df %>% arrange(type.x, desc(logFC.x))
heatmap_breaks <- seq(-2, 2, length.out = 100)
annotation_data <- data.frame(type = df_filtered$type.x) # Assuming type is consistent across both dataframes
first_occurrence <- !duplicated(df_filtered$type.x)
df_filtered$Row_Label <- ifelse(first_occurrence, df_filtered$type.x, "")
annotation_col_df <- data.frame(Labels = annotation_labels)
rownames(annotation_col_df) <- colnames(df_filtered[intensity_columns])
heatmap_obj <- pheatmap::pheatmap(df_filtered[intensity_columns],
main = title,
cluster_rows = FALSE,
cluster_cols = FALSE,
show_colnames = TRUE,
show_rownames = TRUE,
breaks = heatmap_breaks,
border_color = "black",
fontsize = 10,
fontsize_legend = 25,
color = colorRampPalette(rev(brewer.pal(n = 7, name = "PRGn")))(100),
labels_row = df_filtered$Row_Label,
annotation_col = annotation_col_df)
# Save the heatmap
save_pheatmap_pdf(heatmap_obj, paste0("heatmaps_large/", title, "_Zscore_2_limit.pdf"), width = 11, height = 10)
}
create_heatmap_Z_score(df1, df2, title)
labels <- read.csv("labels.csv", stringsAsFactors = FALSE)
df<- read.csv("Blank_subtracted.csv", stringsAsFactors = FALSE)
# Loading required libraries
library(ggplot2)
library(ggrepel) # for better label positioning
setwd("C:/Users/Connor Beveridge/Box/connor_beveridge/New/Burda_Lab_final_to_be_CLAW_WD_V1")
labels <- read.csv("labels.csv", stringsAsFactors = FALSE)
df<- read.csv("Blank_subtracted.csv", stringsAsFactors = FALSE)
# Loading required libraries
library(ggplot2)
library(ggrepel) # for better label positioning
library(reshape2) # for melting dataframes
library(FactoMineR) # for PCA
# Transposing the df dataframe as you want dots per column
df_t <- t(df)
# Performing PCA on the transposed data
res.pca <- PCA(df_t, graph = FALSE)
# Extracting the PCA results
pca_data <- as.data.frame(res.pca$ind$coord)
# Merging the PCA results with the labels dataframe
pca_data$Sample.Name <- rownames(pca_data)
final_data <- merge(pca_data, labels, by = "Sample.Name")
# Defining the colors and shapes based on your specifications
shape_mapping <- c("28d ISCI" = 2, "healthy" = 1) # 2 is triangle, 1 is circle in ggplot
color_mapping <- c("cKO" = rgb(167/255, 62/255, 186/255), "WT" = "black")
# Plotting the PCA
ggplot(final_data, aes(x = Dim.1, y = Dim.2)) +
geom_point(aes(shape = `time point`, color = Genotype), size = 3) +
scale_shape_manual(values = shape_mapping) +
scale_color_manual(values = color_mapping) +
ggrepel::geom_label_repel(aes(label = Sample.Name), box.padding = 0.5) +
labs(
title = "PCA Plot",
x = paste("PC1: ", round(res.pca$eig[1, 2], 2), "% variance"),
y = paste("PC2: ", round(res.pca$eig[2, 2], 2), "% variance")
) +
theme_minimal()
labels
# Plotting the PCA
ggplot(final_data, aes(x = Dim.1, y = Dim.2)) +
geom_point(aes(shape = `time.point`, color = Genotype), size = 3) +
scale_shape_manual(values = shape_mapping) +
scale_color_manual(values = color_mapping) +
ggrepel::geom_label_repel(aes(label = Sample.Name), box.padding = 0.5) +
labs(
title = "PCA Plot",
x = paste("PC1: ", round(res.pca$eig[1, 2], 2), "% variance"),
y = paste("PC2: ", round(res.pca$eig[2, 2], 2), "% variance")
) +
theme_minimal()
# Transposing the df dataframe as you want dots per column
df_t <- t(df)
# Performing PCA on the transposed data
res.pca <- PCA(df_t, graph = FALSE)
# Extracting the PCA results
pca_data <- as.data.frame(res.pca$ind$coord)
# Merging the PCA results with the labels dataframe
pca_data$Sample.Name <- rownames(pca_data)
final_data <- merge(pca_data, labels, by = "Sample.Name")
# Defining the colors and shapes based on your specifications
shape_mapping <- c("28d ISCI" = 2, "healthy" = 1) # 2 is triangle, 1 is circle in ggplot
color_mapping <- c("cKO" = rgb(167/255, 62/255, 186/255), "WT" = "black")
# Plotting the PCA
ggplot(final_data, aes(x = Dim.1, y = Dim.2)) +
geom_point(aes(shape = `time.point`, color = Genotype), size = 3) +
scale_shape_manual(values = shape_mapping) +
scale_color_manual(values = color_mapping) +
ggrepel::geom_label_repel(aes(label = Sample.Name), box.padding = 0.5) +
labs(
title = "PCA Plot",
x = paste("PC1: ", round(res.pca$eig[1, 2], 2), "% variance"),
y = paste("PC2: ", round(res.pca$eig[2, 2], 2), "% variance")
) +
theme_minimal()
# Defining the colors and shapes based on your specifications
shape_mapping <- c("28d ISCI" = 17, "healthy" = 16) # 2 is triangle, 1 is circle in ggplot
color_mapping <- c("cKO" = rgb(167/255, 62/255, 186/255), "WT" = "black")
# Plotting the PCA
ggplot(final_data, aes(x = Dim.1, y = Dim.2)) +
geom_point(aes(shape = `time.point`, color = Genotype), size = 3) +
scale_shape_manual(values = shape_mapping) +
scale_color_manual(values = color_mapping) +
ggrepel::geom_label_repel(aes(label = Sample.Name), box.padding = 0.5) +
labs(
title = "PCA Plot",
x = paste("PC1: ", round(res.pca$eig[1, 2], 2), "% variance"),
y = paste("PC2: ", round(res.pca$eig[2, 2], 2), "% variance")
) +
theme_minimal()
# Transposing the df dataframe as you want dots per column
df_t <- t(df)
# Performing PCA on the transposed data
res.pca <- PCA(df_t, graph = FALSE)
# Extracting the PCA results
pca_data <- as.data.frame(res.pca$ind$coord)
# Merging the PCA results with the labels dataframe
pca_data$Sample.Name <- rownames(pca_data)
final_data <- merge(pca_data, labels, by = "Sample.Name")
# Defining the colors and shapes based on your specifications
shape_mapping <- c("28d ISCI" = 17, "healthy" = 16) # 17 is triangle, 16 is circle in ggplot
color_mapping <- c("cKO" = rgb(167/255, 62/255, 186/255), "WT" = "black")
# Plotting the PCA
ggplot(final_data, aes(x = Dim.1, y = Dim.2)) +
geom_point(aes(shape = `time.point`, color = Genotype), size = 3) +
scale_shape_manual(values = shape_mapping) +
scale_color_manual(values = color_mapping) +
ggrepel::geom_label_repel(aes(label = Sample.Name), box.padding = 0.5) +
stat_ellipse(aes(group = interaction(`time.point`, Genotype), shape = `time.point`, color = Genotype), type = "norm") + # adding ellipses
labs(
title = "PCA Plot",
x = paste("PC1: ", round(res.pca$eig[1, 2], 2), "% variance"),
y = paste("PC2: ", round(res.pca$eig[2, 2], 2), "% variance")
) +
theme_minimal()
setwd("C:/Users/Connor Beveridge/Box/connor_beveridge/New/Burda_Lab_final_to_be_CLAW_WD_V1")
# Loading required libraries
library(ggplot2)
library(ggrepel) # for better label positioning
library(reshape2) # for melting dataframes
library(FactoMineR) # for PCA
labels <- read.csv("labels.csv", stringsAsFactors = FALSE)
df<- read.csv("Blank_subtracted_and_column_normalized.csv", stringsAsFactors = FALSE)
# Transposing the df dataframe as you want dots per column
df_t <- t(df)
# Performing PCA on the transposed data
res.pca <- PCA(df_t, graph = FALSE)
# Extracting the PCA results
pca_data <- as.data.frame(res.pca$ind$coord)
# Merging the PCA results with the labels dataframe
pca_data$Sample.Name <- rownames(pca_data)
final_data <- merge(pca_data, labels, by = "Sample.Name")
# Defining the colors and shapes based on your specifications
shape_mapping <- c("28d ISCI" = 17, "healthy" = 16) # 17 is triangle, 16 is circle in ggplot
color_mapping <- c("cKO" = rgb(167/255, 62/255, 186/255), "WT" = "black")
# Plotting the PCA
ggplot(final_data, aes(x = Dim.1, y = Dim.2)) +
geom_point(aes(shape = `time.point`, color = Genotype), size = 3) +
scale_shape_manual(values = shape_mapping) +
scale_color_manual(values = color_mapping) +
ggrepel::geom_label_repel(aes(label = Sample.Name), box.padding = 0.5) +
stat_ellipse(aes(group = interaction(`time.point`, Genotype), shape = `time.point`, color = Genotype), type = "norm", level = 0.68) + # adding ellipses
labs(
title = "PCA Plot",
x = paste("PC1: ", round(res.pca$eig[1, 2], 2), "% variance"),
y = paste("PC2: ", round(res.pca$eig[2, 2], 2), "% variance")
) +
theme_minimal()
ggsave("Blank_subtracted_and_column_normalized.svg")
labels <- read.csv("labels.csv", stringsAsFactors = FALSE)
df<- read.csv("Blank_subtracted", stringsAsFactors = FALSE)
# Transposing the df dataframe as you want dots per column
df_t <- t(df)
# Performing PCA on the transposed data
res.pca <- PCA(df_t, graph = FALSE)
# Extracting the PCA results
pca_data <- as.data.frame(res.pca$ind$coord)
# Merging the PCA results with the labels dataframe
pca_data$Sample.Name <- rownames(pca_data)
final_data <- merge(pca_data, labels, by = "Sample.Name")
# Defining the colors and shapes based on your specifications
shape_mapping <- c("28d ISCI" = 17, "healthy" = 16) # 17 is triangle, 16 is circle in ggplot
color_mapping <- c("cKO" = rgb(167/255, 62/255, 186/255), "WT" = "black")
# Plotting the PCA
ggplot(final_data, aes(x = Dim.1, y = Dim.2)) +
geom_point(aes(shape = `time.point`, color = Genotype), size = 3) +
scale_shape_manual(values = shape_mapping) +
scale_color_manual(values = color_mapping) +
ggrepel::geom_label_repel(aes(label = Sample.Name), box.padding = 0.5) +
stat_ellipse(aes(group = interaction(`time.point`, Genotype), shape = `time.point`, color = Genotype), type = "norm", level = 0.68) + # adding ellipses
labs(
title = "PCA Plot",
x = paste("PC1: ", round(res.pca$eig[1, 2], 2), "% variance"),
y = paste("PC2: ", round(res.pca$eig[2, 2], 2), "% variance")
) +
theme_minimal()
ggsave("Blank_subtracted_and_column_normalized.svg")
df<- read.csv("Blank_subtracted", stringsAsFactors = FALSE)
df<- read.csv("Blank_subtracted.csv", stringsAsFactors = FALSE)
# Transposing the df dataframe as you want dots per column
df_t <- t(df)
# Performing PCA on the transposed data
res.pca <- PCA(df_t, graph = FALSE)
# Extracting the PCA results
pca_data <- as.data.frame(res.pca$ind$coord)
# Merging the PCA results with the labels dataframe
pca_data$Sample.Name <- rownames(pca_data)
final_data <- merge(pca_data, labels, by = "Sample.Name")
# Defining the colors and shapes based on your specifications
shape_mapping <- c("28d ISCI" = 17, "healthy" = 16) # 17 is triangle, 16 is circle in ggplot
color_mapping <- c("cKO" = rgb(167/255, 62/255, 186/255), "WT" = "black")
# Plotting the PCA
ggplot(final_data, aes(x = Dim.1, y = Dim.2)) +
geom_point(aes(shape = `time.point`, color = Genotype), size = 3) +
scale_shape_manual(values = shape_mapping) +
scale_color_manual(values = color_mapping) +
ggrepel::geom_label_repel(aes(label = Sample.Name), box.padding = 0.5) +
stat_ellipse(aes(group = interaction(`time.point`, Genotype), shape = `time.point`, color = Genotype), type = "norm", level = 0.68) + # adding ellipses
labs(
title = "PCA Plot",
x = paste("PC1: ", round(res.pca$eig[1, 2], 2), "% variance"),
y = paste("PC2: ", round(res.pca$eig[2, 2], 2), "% variance")
) +
theme_minimal()
ggsave("Blank_subtracted_and_column_normalized.svg")
df<- read.csv("Blank_subtracted_and_column_normalized.csv", stringsAsFactors = FALSE)
# Transposing the df dataframe as you want dots per column
df_t <- t(df)
# Performing PCA on the transposed data
res.pca <- PCA(df_t, graph = FALSE)
# Extracting the PCA results
pca_data <- as.data.frame(res.pca$ind$coord)
# Merging the PCA results with the labels dataframe
pca_data$Sample.Name <- rownames(pca_data)
final_data <- merge(pca_data, labels, by = "Sample.Name")
# Defining the colors and shapes based on your specifications
shape_mapping <- c("28d ISCI" = 17, "healthy" = 16) # 17 is triangle, 16 is circle in ggplot
color_mapping <- c("cKO" = rgb(167/255, 62/255, 186/255), "WT" = "black")
# Plotting the PCA
ggplot(final_data, aes(x = Dim.1, y = Dim.2)) +
geom_point(aes(shape = `time.point`, color = Genotype), size = 3) +
scale_shape_manual(values = shape_mapping) +
scale_color_manual(values = color_mapping) +
ggrepel::geom_label_repel(aes(label = Sample.Name), box.padding = 0.5) +
stat_ellipse(aes(group = interaction(`time.point`, Genotype), shape = `time.point`, color = Genotype), type = "norm", level = 0.68) + # adding ellipses
labs(
title = "PCA Plot",
x = paste("PC1: ", round(res.pca$eig[1, 2], 2), "% variance"),
y = paste("PC2: ", round(res.pca$eig[2, 2], 2), "% variance")
) +
theme_minimal()
ggsave("Blank_subtracted_and_column_normalized.svg")
